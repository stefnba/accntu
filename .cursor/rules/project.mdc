---
description: General project rules
globs: 
alwaysApply: true
---








# **Cursor AI Project Rules**

You are a Senior Developer and an Expert in ReactJS, NextJS, JavaScript, TypeScript, HTML, CSS and modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix), following best practices and adhering to the principles of clean code and robust architecture.

## **1. Code Style & Structure**



### **TypeScript**
- Use **strict TypeScript** with well-defined types.
- No `any` types unless absolutely necessary.
- Store shared types in `features/[feature]/types.ts`.

### **File Organization**

- Use lowercase with dashes for directory names (e.g., `components/auth-wizard`).

```
project-root/
└── drizzle/                      # Drizzle 
    ├── migrations/               # Database migrations
└── src/                          # Code directory
    ├── app/                      # Next.js App Router (only pages)
    │   ├── api/                  # API routes (entry points to Hono)
    │   ├── [feature]/            # Feature-specific pages
    │   ├── layout.tsx            # Root layout
    │   └── page.tsx              # Home page
    ├── hooks/                    # Hooks used for entire project, e.g. UseIsMobile
    ├── providers/                # Providers used for entire project, e.g. ThemeProvider, QueryProvider
    ├── features/                 # Client-side feature-based organization
    │   ├── [feature]/            # Feature-related
    │   │   ├── components/       # Feature UI components
    │   │   ├── hooks/            # Feature hooks
    │   │   ├── schemas/          # Feature schemas
        │   ├── store/            # Zustand/Nuqs state management
    │   │   ├── api/              # TanStack Query API hooks
    │   │   └── utils/            # Feature utilities
    │   └── shared/               # Shared components and utilities
    ├── server/                   # Server-side code
    │   ├── db/                   # Database configuration
    │   │   ├── schemas/          # Drizzle schema
    │   │   └── index.ts          # DB client
    │   ├── features/             # Feature-based server organization
    │   │   └── [feature]/        # Feature
    │   │       ├── routes.ts     # Feature routes
    │   │       ├── queries.ts    # Database queries using Drizzle ORM
    │   │       ├── services.ts   # Feature Business logic
    │   │       └── utils.ts      # Feature utilities
    │   │       └── schemas.ts    # Zod validation schemas
    │   ├── lib/                  # Server-side shared libraries
    │   ├── middleware/           # Shared middleware
    │   ├── utils/                # Shared server utilities
    │   └── index.ts              # Main Hono API setup
    └── lib/                      # Shared libraries (client-side)
    └── components/               # Shared UI components
        │   ├── ui/               # Reusable UI elements (modals, buttons, inputs, tables)
        │   ├── layout/           # Layout-related components (headers, sidebars)
```

### **Component Structure**
- Use `"use client"` for client components but where possible keep server components.
- Keep components **focused and single-responsibility**.
- Follow **composition over inheritance**.

---

## **2. State Management**

### **Zustand**
- Use Zustand for feature-based state management.
- Keep **stores modular**, defining them in `features/[feature]/stores/`.

### **Nuqs**
- Use Nuqs for **URL-based search params state** (modals, filters, sorting).

---

## **3. API Communication**

### **Frontend**
- Use **TanStack Query** for API calls.
- Store API hooks in `features/[feature]/api/`, ever call API endpoints directly from a component.
- Implement **error handling, caching**, and **loading states**.

### **Backend (Hono)**
- Use **Hono** as backend for all API routes, no server actions.
- Implement **middleware for auth, error handling**.
- Use **Zod for validation** of request params/body.
- Follow a **consistent API response structure**.

### **Type Safety**
- Use Hono's RPC to achieve a **type-safe API client**.

---

## **4. Authentication**
- Custom **auth implementation** (no NextAuth).
- Supports **GitHub, Google, Passkey, Email OTP** (no passwords).
- Uses **secure HTTP-only cookies** for session management.
- **CSRF protection & rate limiting** applied.

---

## **5. UI Components**

### **UI and Styling**
- Use modern UI frameworks (e.g., Tailwind CSS, Shadcn UI, Radix UI) for styling.
- Install Shadcn components, don't write them yourself.
- Implement consistent design and responsive patterns across platforms.
- Use responsive design with a mobile-first approach.

### **Component Library**
- Follow **Tailwind CSS v4** best practices.
- Ensure **accessibility** compliance.

### **Forms**.
- Use **React Hook Form + Zod** for forms and validation.
- Store schemas in `features/[feature]/schemas/`.
- Provide **proper user feedback**.

---

## **7. Error Handling**

### **Client-Side**
- Use **toast notifications** for errors.
- Implement **error boundaries**.
- **Graceful UI degradation** for failed requests.

### **Server-Side**
- **Consistent API error responses**.
- Proper **logging & monitoring**.
- **Graceful handling of missing or invalid data**.

---

## **8. Testing**

### **Unit Tests**
- Use **Vitest** for unit testing.
- Test **hooks, utilities, stores**.

### **Integration Tests**
- Test **API endpoints, auth, database queries**.

---

## **9. Performance Optimization**

### **Best Practices**
- Optimize **bundling, code splitting**.
- Implement **caching & pagination**.
- Use **skeleton loaders** for pending data.

---

## **10. Documentation & Environment Config**

### **Documentation**
- Maintain **README.md** with **setup & deployment steps**.
- Document **API endpoints & environment variables**.
- Create clear and concise comments for all created functions

### **Environment Variables**
- Store in `.env` with **proper typing**.
- Handle missing variables gracefully.




## 2. State Management

### Zustand
- Use Zustand for state management, but keep statement modular and small
- Create separate stores per feature in `features/[feature]/stores/`
- Implement proper TypeScript types for store states and actions

### Nuqs
- Use nuqs as type-safe search params state manager for modals, sheets, filtering so it can be shared via URL copy-paste

## 3. API Communication

### Frontend
- Use React Query for state management of API calls
- Implement proper error handling and loading states
- Define reusable query hooks in `features/[feature]/api/`
- Configure with reasonable defaults (staleTime, retry policies)

### Hono for backend
- Use Hono for API routes in Next.js
- Use consistent response format
- Proper error handling and status codes, see more below
- use zod validator for validating request params, etc.

### Type Safety
- Use type-safe API client for all requests
- Handle errors consistently
- Include proper typing for request/response data


## 4. Authentication

### Methods
- Support multiple auth providers (GitHub, Google, Passkey, email OTP), no password auth
- Implement session cookies
- Use secure HTTP-only cookies
- Handle auth state persistently

### Security
- Implement proper CSRF protection
- Use secure cookie settings
- Implement rate limiting
- Proper error handling and user feedback

## 6. UI Components

### Component Library
- Use shadcn/ui as base component library
- Maintain consistent styling with Tailwind CSS
- Implement proper accessibility
- Use proper component composition

### Forms
- Use React Hook Form for form handling
- Implement Zod schemas for validation, save all schemas in  `features/[feature]/schemas/`
- Proper error handling and user feedback
- Consistent form layouts

## 7. Error Handling

### Client-Side
- Use toast notifications for user feedback
- Implement proper error boundaries
- Handle loading states
- Proper form validation feedback

### Server-Side
## Error Handling

The application uses a comprehensive error handling system located in `src/server/lib/error/`. Here are the key rules for working with errors:

1. **Always use the error factory**: Create errors using the `errorFactory` methods rather than throwing raw errors or creating `BaseError` instances directly.

   ```typescript
   // ❌ Don't do this
   throw new Error('Something went wrong');

   // ✅ Do this instead
   throw errorFactory.createServiceError(
     'Failed to process data',
     'INTERNAL_SERVER_ERROR',
     originalError
   );
   ```

1a. **Understand the two error creation approaches**: The system provides two ways to create errors:

   - **Direct error creation**: Use `errorFactory` methods directly for business logic errors:
     ```typescript
     throw errorFactory.createAuthError('User not found', 'AUTH.USER_NOT_FOUND', 404);
     ```

   - **Handler function approach**: Use specialized handler functions for external system errors:
     ```typescript
     // For database errors
     handleDatabaseError(error, 'fetch user operation');

     // For validation errors
     handleZodError(zodError);
     ```

   Use handler functions for database and validation errors as they require specialized handling.
   Use direct error creation for business logic, authentication, and other application-specific errors.

2. **Use appropriate error types**: Choose the right factory method based on where the error occurs:
   - `createApiError`: For errors in API routes/controllers
   - `createServiceError`: For errors in business logic
   - `createDatabaseError`: For database errors
   - `createValidationError`: For data validation errors
   - `createExternalError`: For errors in external service interactions
   - `createAuthError`: For authentication errors

3. **Include error codes**: Always use the predefined error codes from `ErrorCode` type. If you need a new code, add it to the `ErrorCode` type in `types.ts`.

4. **Chain errors when appropriate**: When catching errors from lower layers, either:
   - Add context to the existing error using `addToChain`
   - Create a new error with the original as the cause

   ```typescript
   try {
     // Operation that might throw
   } catch (error) {
     if (error instanceof BaseError) {
       // Add context to existing error
       throw error.addToChain('service', 'Additional context', 'NEW.ERROR_CODE');
     }
     // Create new error with original as cause
     throw errorFactory.createServiceError(
       'Higher level message',
       'SERVICE.ERROR_CODE',
       error instanceof Error ? error : undefined
     );
   }
   ```

5. **Set appropriate status codes**: Use HTTP status codes that match the error type:
   - 400: Bad request (validation errors)
   - 401: Unauthorized (authentication errors)
   - 403: Forbidden (authorization errors)
   - 404: Not found
   - 409: Conflict (e.g., unique constraint violations)
   - 429: Too many requests
   - 500: Internal server error
   - 502: Bad gateway (external service errors)

6. **Handle errors in routes**: All routes should be wrapped with the error handler middleware:

   ```typescript
   import { errorHandler } from '../lib/error';

   const app = new Hono();
   app.use('*', errorHandler());
   ```

7. **Client-side error handling**: Use the provided utilities for handling errors on the client:

   ```typescript
   import { handleApiResponse, isSuccessResponse } from '../lib/error/client';

   const result = handleApiResponse(data);
   if (isSuccessResponse(result)) {
     // Handle success
   } else {
     // Handle error
   }
   ```

## Database Operations

When working with database operations:

1. **Use the withDb utility**: Always wrap database operations with the `withDb` or `withDbNullable` utility:

   ```typescript
   import { withDb } from '../lib/error/db';

   // For operations that should never return null
   const result = await withDb(
     () => db.select().from(users).where(eq(users.id, userId)).limit(1),
     'find user by ID'
   );

   // For operations that might legitimately return null
   const result = await withDbNullable(
     () => db.select().from(users).where(eq(users.id, userId)).limit(1),
     'find user by ID'
   );
   ```

2. **Provide operation descriptions**: Always include a descriptive operation name as the second parameter to `withDb` and `withDbNullable`.

## Validation

For data validation:

1. **Use Zod schemas**: Define Zod schemas for all data validation.

2. **Use the zValidator middleware**: Validate request data using the `zValidator` middleware:

   ```typescript
   import { zValidator } from '@hono/zod-validator';

   const UserSchema = z.object({
     name: z.string(),
     email: z.string().email(),
   });

   app.post('/users', zValidator('json', UserSchema), async (c) => {
     const data = c.req.valid('json');
     // Process validated data
   });
   ```

3. **Handle validation errors**: The global error handler will catch and format Zod validation errors automatically.

## API Responses

For API responses:

1. **Use createSuccessResponse**: Always use the `createSuccessResponse` utility for success responses:

   ```typescript
   import { createSuccessResponse } from '../lib/error/response';

   return c.json(createSuccessResponse({ user }));
   ```

2. **Check response types**: Use the `isSuccessResponse` type guard to safely access response data:

   ```typescript
   if (isSuccessResponse(response)) {
     // Safe to access response.data
   }
   ```





## 8. Testing

### Unit Tests
- Use Vitest for unit testing
- Test hooks and utilities
- Implement proper mocking
- Maintain good test coverage

### Integration Tests
- Test API endpoints
- Test authentication flows
- Test database operations
- Test form submissions

## 9. Performance

### Optimization
- Implement proper caching strategies
- Use proper bundling and code splitting
- Optimize images and assets
- Monitor performance metrics

### Loading States
- Implement proper loading indicators
- Use skeleton loaders where appropriate
- Handle error states gracefully
- Provide feedback for long operations

## 10. Documentation

### Code
- Clear and concise comments for all created functions
- Document complex logic
- Document API endpoints
- Document type definitions

### Project
- Maintain README.md
- Document setup process
- Document deployment process
- Document environment variables

## 11. Environment & Configuration

### Variables
- Use proper .env files
- Document all required variables
- Use proper typing for env variables
- Handle missing variables gracefully

### Development
- Use proper development tools
- Maintain consistent formatting
- Use proper linting rules
- Implement pre-commit hooks

These rules should be followed to maintain code quality, consistency, and maintainability throughout the project.



