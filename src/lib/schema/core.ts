import { StandardSchemasBuilder } from '@/lib/schema/standard';
import type { TFeatureSchemaObject, TFeatureSchemas } from '@/lib/schema/types';
import { FeatureTableConfig } from '@/server/lib/db/table/feature-config';
import { paginationSchema } from '@/server/lib/db/table/feature-config/schemas';
import { InferTableSchema, TFeatureTableConfig } from '@/server/lib/db/table/feature-config/types';
import { Prettify } from '@/types/utils';
import { Table } from 'drizzle-orm';
import { createInsertSchema, createSelectSchema, createUpdateSchema } from 'drizzle-zod';
import { z } from 'zod';

export class FeatureSchemasBuilder<
    const TSchemas extends Record<string, TFeatureSchemas>,
    const TTable extends Table,
    const TConfig extends TFeatureTableConfig<TTable>,
    const TTableConfig extends FeatureTableConfig<TTable, TConfig> = FeatureTableConfig<
        TTable,
        TConfig
    >,
> {
    /** The builder schemas */
    schemas: TSchemas;

    /** Table configuration */
    tableConfig: TTableConfig;

    /** Drizzle table definition */
    table: TTable;

    constructor({ schemas, config }: { schemas: TSchemas; config: TTableConfig }) {
        this.schemas = schemas;
        this.tableConfig = config;
        this.table = config.getTable();
    }

    /**
     * Adds a custom schema definition to the builder.
     *
     * The callback receives helper utilities and raw schema definitions derived from the table config.
     * You can use these to construct custom service, endpoint, and query schemas.
     *
     * @param key - The key for the new schema (e.g., 'customAction')
     * @param config - Callback function that returns the schema definition object
     *
     * @example
     * ```typescript
     * const schemas = createFeatureSchemas(config).addSchema('customQuery', ({ schemas }) => {
     *     return schemas.base;
     * });
     * ```
     */
    addSchema<const K extends string, const O extends TFeatureSchemaObject>(
        key: K,
        config: (args: {
            schemas: {
                /** The raw table schemas generated by drizzle-zod */
                table: {
                    /** The insert schema (all fields required, no defaults) */
                    insert: InferTableSchema<TTable, 'insert'>;
                    /** The select schema (all fields as stored in DB) */
                    select: InferTableSchema<TTable, 'select'>;
                    /** The update schema (all fields optional) */
                    update: InferTableSchema<TTable, 'update'>;
                };
                /** The combined input schemas used for standard operations */
                input: {
                    /** The update input schema (data + ids + userId) */
                    update: ReturnType<
                        FeatureTableConfig<TTable, TConfig>['buildUpdateInputSchema']
                    >;
                    /** The create input schema (data + userId) */
                    create: ReturnType<
                        FeatureTableConfig<TTable, TConfig>['buildCreateInputSchema']
                    >;
                };
                /** The raw data schemas (excluding system fields like userId) */
                inputData: {
                    /** The update input data schema */
                    update: z.ZodObject<TConfig['updateData']>;
                    /** The insert input data schema */
                    insert: z.ZodObject<TConfig['createData']>;
                };
                /** The schema for columns returned by queries */
                return: z.ZodObject<TConfig['returnCols']>;
                /** The base schema for the entity */
                base: z.ZodObject<TConfig['base']>;
                /** The ID schema */
                id: z.ZodObject<TConfig['id']>;
                /** The user ID schema */
                userId: z.ZodObject<TConfig['userId']>;
            };
            helpers: {
                /** Helper to build identifier schema (ids + userId) */
                buildIdentifierSchema: () => ReturnType<
                    FeatureTableConfig<TTable, TConfig>['buildIdentifierSchema']
                >;
                /** Helper to get pagination schema */
                buildPaginationSchema: () => typeof paginationSchema;
                /** Helper to build filters schema */
                buildFiltersSchema: () => z.ZodObject<TConfig['filters']>;
            };
        }) => O
    ) {
        const schema = config({
            helpers: {
                buildIdentifierSchema: () => this.tableConfig.buildIdentifierSchema(),
                buildPaginationSchema: () => paginationSchema,
                buildFiltersSchema: () => this.tableConfig.buildFiltersSchema(),
            },
            schemas: {
                table: {
                    insert: createInsertSchema(this.table),
                    select: createSelectSchema(this.table),
                    update: createUpdateSchema(this.table),
                },
                input: {
                    update: this.tableConfig.buildUpdateInputSchema(),
                    create: this.tableConfig.buildCreateInputSchema(),
                },
                inputData: {
                    update: this.tableConfig.getUpdateDataSchema(),
                    insert: this.tableConfig.getCreateDataSchema(),
                },
                return: this.tableConfig.getReturnColumnsSchema(),
                base: this.tableConfig.getBaseSchema(),
                id: this.tableConfig.getIdSchema(),
                userId: this.tableConfig.getUserIdSchema(),
            },
        });

        return new FeatureSchemasBuilder<TSchemas & Record<K, O>, TTable, TConfig, TTableConfig>({
            schemas: { ...this.schemas, [key]: schema },
            config: this.tableConfig,
        });
    }

    /**
     * Allows adding standard schemas selectively using the StandardSchemasBuilder.
     *
     * Useful if you only want specific standard operations (e.g., only `create` and `getById`).
     *
     * @param standard - Callback that receives a StandardSchemasBuilder instance
     */
    withStandard<TBuilder extends StandardSchemasBuilder<TTable, TConfig, TTableConfig>>(
        standard: (
            b: ReturnType<typeof StandardSchemasBuilder.create<TTable, TConfig, TTableConfig>>
        ) => TBuilder
    ) {
        const builder = StandardSchemasBuilder.create<TTable, TConfig, TTableConfig>(
            this.tableConfig
        );
        const standardBuilder = standard(builder);
        const standardSchemas = standardBuilder.done();

        return new FeatureSchemasBuilder<
            TSchemas & TBuilder['schemas'],
            TTable,
            TConfig,
            TTableConfig
        >({
            schemas: { ...this.schemas, ...standardSchemas },
            config: this.tableConfig,
        });
    }

    /**
     * Registers all standard schemas (create, createMany, updateById, getById, removeById, getMany).
     *
     * This is the recommended way to quickly scaffold standard operations for a feature.
     */
    registerAllStandard() {
        const builder = StandardSchemasBuilder.create<TTable, TConfig, TTableConfig>(
            this.tableConfig
        );
        const standardSchemas = builder.all().done();

        return new FeatureSchemasBuilder<
            TSchemas & typeof standardSchemas,
            TTable,
            TConfig,
            TTableConfig
        >({
            schemas: { ...this.schemas, ...standardSchemas },
            config: this.tableConfig,
        });
    }

    /**
     * Finalizes the builder and returns the accumulated schemas object.
     */
    build(): Prettify<{
        [K in keyof TSchemas as string extends K ? never : K]: TSchemas[K];
    }> {
        return this.schemas;
    }
}
